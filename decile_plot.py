"""
decile_plot.py
==============

Utility module to create performance plots by score *deciles* (or any number of
equal‑frequency buckets) together with Kolmogorov‑Smirnov (KS) statistics.

Key features
------------
* **Vectorised**: no `for` loops over rows – built entirely on top of pandas.
* **Reusable**: the main public function :pyfunc:`decile_analysis_plot` returns
  both the underlying table and an interactive Plotly ``Figure``.
* **Documented & typed**: full docstrings and type hints for IDE autocompletion.
* **Customisable**: colours, number of bins, axis titles and fonts are exposed
  via parameters.
* **Self‑contained demo**: run the module directly to see a working example
  using synthetic data.

Example
-------
>>> import pandas as pd
>>> from decile_plot import decile_analysis_plot
>>> df = pd.read_parquet("my_scored_dataset.parquet")
>>> fig, ks_value, table = decile_analysis_plot(df,
...                                             score_col="y_proba",
...                                             target_col="bad_flag")
>>> fig.show()

Author
------
Generated by ChatGPT o3 – {date}.

""".format(date=datetime.datetime.utcnow().strftime("%Y‑%m‑%d %H:%M UTC"))

from __future__ import annotations

import datetime
from typing import Tuple

import numpy as np
import pandas as pd
import plotly.graph_objects as go
from plotly.subplots import make_subplots


# ============================ Helper functions ============================


def _format_thousands(x: int | float) -> str:
    """Format numbers with thousands separator and no decimals."""
    return f"{int(x):,}".replace(",", ".")


def _assign_equal_freq_bins(
    series: pd.Series, n_bins: int = 10, ascending: bool = True
) -> pd.Series:
    """Return **1‑based** integer labels representing equal‑frequency bins.

    Parameters
    ----------
    series :
        Numeric values to be ranked.
    n_bins :
        Number of buckets to create (default 10).
    ascending :
        If *True* (default) smaller scores are *better* (i.e. decile 1 has the
        lowest score). Set to *False* if higher scores are better.

    Notes
    -----
    The implementation uses :pyfunc:`pandas.qcut`.  Duplicate bin edges are
    handled by adding a tiny amount of random noise.
    """
    # Add tiny jitter if many ties would cause qcut to fail
    jitter = np.random.uniform(0, 1e-9, size=series.shape[0])
    ranked = series + jitter

    if not ascending:
        ranked = -ranked

    bins = pd.qcut(
        ranked.rank(method="first"),
        q=n_bins,
        labels=range(1, n_bins + 1),
    ).astype(int)

    return bins


# ============================ KS calculation ============================


def ks_table(
    df: pd.DataFrame,
    score_col: str,
    target_col: str,
    n_bins: int = 10,
    ascending: bool = True,
    bin_col: str = "decile",
) -> Tuple[pd.DataFrame, float]:
    """Return a table with quantities per decile and the KS statistic.

    The returned dataframe contains the following columns:

    * ``total`` – number of rows in the decile
    * ``bad``   – count of ``target_col == 1``
    * ``good``  – count of ``target_col == 0``
    * ``bad_rate``
    * ``cum_bad`` / ``cum_good`` – cumulative shares
    * ``KS`` – |cum_bad ‑ cum_good|

    Parameters
    ----------
    df :
        Input dataframe **must** contain *score* and *target* columns.
    score_col :
        Column with model scores / probabilities.
    target_col :
        Binary target where *1 = event/bad* and *0 = non‑event/good*.
    n_bins :
        Number of buckets (default 10 for deciles).
    ascending :
        *True* if lower scores are better (typical for probabilities),
        otherwise *False*.
    bin_col :
        Name of the column with bin labels to be created.

    Returns
    -------
    table :
        Aggregated metrics per bin.
    ks_value :
        KS statistic (float between 0 and 1).
    """
    if target_col not in df.columns:
        raise KeyError(f"Target column '{target_col}' not found.")
    if score_col not in df.columns:
        raise KeyError(f"Score column '{score_col}' not found.")

    work = df[[score_col, target_col]].copy()
    work[bin_col] = _assign_equal_freq_bins(
        work[score_col], n_bins=n_bins, ascending=ascending
    )

    grp = (
        work.groupby(bin_col, observed=True)
        .agg(total=(target_col, "size"), bad=(target_col, "sum"))
        .sort_index()
    )
    grp["good"] = grp["total"] - grp["bad"]
    grp["bad_rate"] = grp["bad"] / grp["total"]
    grp["cum_bad"] = grp["bad"].cumsum() / grp["bad"].sum()
    grp["cum_good"] = grp["good"].cumsum() / grp["good"].sum()
    grp["KS"] = (grp["cum_bad"] - grp["cum_good"]).abs()

    ks_value = grp["KS"].max()

    return grp.reset_index(), ks_value


# ============================ Plotting ===================================


def decile_analysis_plot(
    df: pd.DataFrame,
    score_col: str,
    target_col: str,
    n_bins: int = 10,
    ascending: bool = True,
    bar_color: str = "#4527a0",  # purple
    line_color: str = "#fa6300",  # orange
    font_family: str = "Arial Black",
    title_prefix: str = "Ordenação por decil",
) -> Tuple[go.Figure, float, pd.DataFrame]:
    """Return a Plotly Figure replicating the *KS by decile* chart.

    Parameters
    ----------
    df :
        Data with score and binary target.
    score_col, target_col :
        Column names.
    n_bins :
        Number of equally‑sized buckets (default 10).
    ascending :
        If *True* lower scores are better.
    bar_color, line_color :
        Colours for bar & line series.
    font_family :
        Font applied to titles and texts.
    title_prefix :
        Base for the main title. KS and percent are appended automatically.

    Returns
    -------
    fig :
        Interactive Plotly Figure.
    ks_value :
        KS statistic (0‑1 range).
    table :
        DataFrame with per‑decile metrics (see :pyfunc:`ks_table`).
    """
    table, ks_value = ks_table(
        df, score_col, target_col, n_bins=n_bins, ascending=ascending
    )

    mean_default_rate = table["bad"].sum() / table["total"].sum()

    fig = make_subplots(specs=[[{"secondary_y": True}]])

    # Bars – #contracts per decile
    fig.add_bar(
        x=table["decile"].astype(str),
        y=table["total"],
        name="Qtd contrato decil",
        text=table["total"].apply(_format_thousands),
        textfont=dict(family=font_family),
        marker_color=bar_color,
        secondary_y=False,
    )

    # Line – default rate %
    fig.add_scatter(
        x=table["decile"].astype(str),
        y=table["bad_rate"],
        name="Taxa default",
        mode="lines+markers+text",
        text=table["bad_rate"].map(lambda x: f"{x:.2%}"),
        textposition="top center",
        textfont=dict(family=font_family, color=line_color),
        line=dict(color=line_color),
        marker=dict(color=line_color),
        secondary_y=True,
    )

    # Mean line
    fig.add_hline(
        y=mean_default_rate,
        line_dash="dash",
        line_color="#059fed",
        secondary_y=True,
        annotation_text="<b>Média</b>",
        annotation_font_color="#059fed",
    )

    # Axis titles
    fig.update_xaxes(title_text="Decil", title_font_family=font_family)
    fig.update_yaxes(
        title_text="<b>Total Ocorrências<b>",
        secondary_y=False,
        title_font_family=font_family,
    )
    fig.update_yaxes(
        title_text="<b>Taxa target – MEC2<b>",
        secondary_y=True,
        tickformat=".2%",  # percent
    )

    # Layout / title
    fig.update_layout(
        title=f"{title_prefix} – KS {ks_value:.2%}",
        title_font_family=font_family,
        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
        bargap=0.2,
        template="simple_white",
    )

    return fig, ks_value, table


# ============================ Self‑contained demo ========================


def _demo() -> None:  # pragma: no cover – only for visual test
    """Generate a demo using synthetic data."""
    np.random.seed(42)
    n = 50_000
    scores = np.random.beta(a=2, b=5, size=n)  # skewed distribution
    # True default probability correlated with score
    probs = 0.02 + (scores ** 2) * 0.5
    target = (np.random.rand(n) < probs).astype(int)

    df_demo = pd.DataFrame({"score": scores, "bad_flag": target})

    fig, ks_value, table = decile_analysis_plot(
        df_demo, score_col="score", target_col="bad_flag", ascending=False
    )

    print(table)
    print(f"KS = {ks_value:.4f}")
    fig.show()


if __name__ == "__main__":
    _demo()
